\chapter{Технологический раздел}

В данном разделе приведены требования к программному обеспечению, средства реализации, структура программного обеспечения, листинги кода и интерфейс программы.

\section{Требования к ПО}
Программа должна предоставлять следующие возможности:
\begin{itemize}
	\item загружать модель трованта из файла;
	\item осуществлять перемещение и вращение данной модели;
	\item добавлять и перемещать источники света;
	\item производить визуализацию роста и размножения тровантов.
\end{itemize}

Входными данными являются:
\begin{itemize}
	\item модель трованта в виде набора координат вокселей;
	\item количество итераций;
	\item интенсивность роста;
	\item точки роста дочерних тровантов.
\end{itemize}

На выходе получается трехмаерная сцена с отображенными на ней объектами и представлена анимация роста и размножения трованта.
\section{Средства реализации}
Для реализации ПО был выбран язык программирования python [7]. Данный выбор обусловлен следующими причинами:
\begin{itemize}
	\item python поддерживает объектно-ориентированный подход;
	\item обширный функционал языка;
	\item большое количество литературы и информации по языку;
	\item имеющийся у меня опыт написания программ на данном языке.
\end{itemize}

В качестве среды разработки была выбрана среда Visual Studio Code. Для представления пользовательского интерфейса была выбрана библиотека PyQt5 [4].

\section{Структура программного обеспечения}
\textbf{Программа реализована с помощью следующих модулей}:
\begin{itemize}
	\item \verb;main.py; --- точка входа в программу и загрузка интерфейса;
	\item \verb;voxelmodel.py; --- содержит класс вокселя и воксельной модели;
	\item \verb;octtree.py; --- содержит класс октодерева;
	\item \verb;builder.py; --- содержит класс Builder, осуществляющий чтение файла и создание воксельной модели;
	\item \verb;drawer.py; --- содержит класс QDrawer, осуществляющие отрисовку сцены;
	\item \verb;commands.py; --- содержит классы команд всех действий над сценой и объектами;
	\item \verb;managers.py; --- содержит классы менеджеров загрузки, отрисовки и анимации;
	\item \verb;buffer.py; --- содержит реализацию z-буффера;
	\item \verb;scene.py; --- содержит класс сцены, в котором хранятся все модели и источники света;
	\item \verb;sceneinterface.py; --- содержит класс SceneInterface, отвечающий за выполнение команд;
	\item \verb;visitor.py; --- содержит классы, выполняющие перемещение и поворот моделей;
	\item \verb;visualizer.py; --- содержит методы, взаимодействующие с drawer-ом;
	\item \verb;baseobject.py; --- содерджит классы Point и Vector;
	\item \verb;invisibleobject.py; --- содержит классы Camera и LightSource;
	\item \verb;visibleobject.py; --- содержит класс Polygon;
	\item \verb;window.py; --- содержит интерфейс и отвечает за его функции.
\end{itemize}

\section{Реализованные алгоритмы}

В листинге \ref{intensity} представлена реализация метода рассчета интенсивности цвета полигона по формуле Ламберта.

\begin{lstlisting}[label=intensity,caption=Метод рассчета интенсивности цвета]
def get_color(self, lights):
        x, y, z = 0, 0, 0
        for p in self.get_points():
            xt, yt, zt = p.get_position()
            x += xt
            y += yt
            z += zt

        centroid = Point(x / 3, y / 3, z / 3)
        normal = self.get_normal().normalize()

        intensity = 0.4
        for light in lights:
            v = Vector().from_points(light, centroid).normalize()
            cos = max(v.scalar_multiplication(normal), 0)
            intensity += light.intensity * cos

        rgb = list(QColor(self.color).getRgbF())

        rgb[0] *= intensity
        rgb[1] *= intensity
        rgb[2] *= intensity

        return QColor().fromRgbF(rgb[0], rgb[1], rgb[2])
\end{lstlisting}

\newpage

В листингах \ref{grow_alg_1}-\ref{grow_alg_2} представлена реализация алгоритма роста тровантов.

\begin{lstlisting}[label=grow_alg_1,caption=Алгоритм роста тровантов(часть 1)]
    def grow(self):
        for i in range(len(self.scene.objects)):
            model = self.scene.get_model(i)
            if model.status == 1 or model.iterations > 3:
                model.rotate_cancel()
                tree = OctTree()
                tree.create_tree(model)

                arr = []

                for j in range(len(tree.zones)):
                    for i in range(len(tree.zones[j])):
                        for z in range(len(self.visitors[j])):
                            voxel = copy.deepcopy(tree.zones[j][i])
                            voxel.accept(self.visitors[j][z])
                            arr.append(voxel)

                model.voxels = arr
                model.rotate_repeat()

                model.iterations += 1

                model.delete_excess()

    def grow_childs(self):
        for i in range(len(self.scene.objects)):
            model = self.scene.get_model(i)
            if not(model.status) and model.iterations < 4:
                model.iterations += 1

                filename = "models/new_stone_2/" + str(model.iterations)\
                 + ".txt"
                builder = ModelBuilder(filename)
                new_model = builder.init_model()

                main_center = self.scene.get_model(0).center
                x_offset, y_offset, z_offset = 30 + \
                (6 + 5 * self.intensity) * model.iterations, - 15 - \
                (7 + 5 * self.intensity) * model.iterations, 30 + \
                (6 + 5 * self.intensity) * model.iterations
                visitor = MoveVisitor(main_center.x - new_model.center.x +\
                x_offset, main_center.y - new_model.center.y + \
                y_offset, main_center.z - new_model.center.z + z_offset)
                new_model.accept(visitor)
\end{lstlisting}

\begin{lstlisting}[label=grow_alg_2,caption=Алгоритм роста тровантов(часть 2)]
                for visitor in self.rotate_child:
                    new_model.accept(visitor)
                new_model.rotate_history = []
                new_model.center = copy.deepcopy(main_center)
                new_model.rotate_history = copy.deepcopy(model.\
                rotate_history)
                new_model.rotate_repeat()

                new_model.iterations = model.iterations
                new_model.status = model.status

                self.scene.change_object(new_model, i)
\end{lstlisting}

В листингах \ref{buffer_1}-\ref{buffer_2} представлена реализация алгоритма z-буффера.

\begin{lstlisting}[label=buffer_1,caption=Алгоритм z-буффера(часть 1)]
class ZBuffer(object):
    def __init__(self, visualizer: Visualizer, width=900, height=900):
        self.width = width
        self.height = height
        self.visualizer = visualizer
        self._buf = [[-6000 for _ in range(width)] for __ in range(height)]

    def process_polygon(self, polygon: Polygon, light):
        color = polygon.get_color(light)

        points = polygon.get_points()
        x = [floor(points[i].x) for i in range(3)]
        y = [floor(points[i].y) for i in range(3)]

        ymax = min(max(y), self.height)
        ymin = max(min(y), 0)

        x1 = x2 = 0
        z1 = z2 = 0
        for y_current in range(ymin, ymax+1):
            first_cycle = 1
            for n in range(3):
                n1 = 0 if n == 2 else n + 1
                if y_current >= max(y[n], y[n1]) or \
                y_current < min(y[n], y[n1]):
                    continue

                m = float(y[n] - y_current) / (y[n]-y[n1])
\end{lstlisting}

\newpage

\begin{lstlisting}[label=buffer_2,caption=Алгоритм z-буффера(часть 2)]
                if first_cycle == 0:
                    x2 = x[n] + floor(m * (x[n1] - x[n]))
                    z2 = points[n].z + m * (points[n1].z - points[n].z)
                else:
                    x1 = x[n] + floor(m * (x[n1] - x[n]))
                    z1 = points[n].z + m * (points[n1].z - points[n].z)

                first_cycle = 0

            if x2 < x1:
                x2, x1 = x1, x2
                z2, z1 = z1, z2

            x_max = min(x2, self.width)
            x_min = max(x1, 0)
            for x_current in range(x_min, x_max):
                m = float(x1 - x_current) / (x1 - x2)
                z_current = z1 + m * (z2 - z1)
                self.process_point(x_current, y_current, \
                int(z_current), color)

    def process_point(self, x: int, y: int, z: int, color):
        if z > self._buf[x][y]:
            self._buf[x][y] = z
            self.visualizer.drawPoint(x, y, color)

    def safe_process_point(self, x: int, y: int, z: int, width: int, \
    height: int, color):
        if x < 0 or x >= width or y < 0 or y >= height:
            return
        elif z > self._buf[x][y]:
            self._buf[x][y] = z
            self.visualizer.drawWidePoint(x, y, color)
\end{lstlisting}

\newpage

\section{Интерфейс программы}

На рисунке \ref{interface} представлен интерфейс программы.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.3]{assets/interface.jpg}
	\end{center}
	\caption{Интерфейс программы}
	\label{interface}
\end{figure}

Интерфейс представляет возможности взаимодействия с моделями и источниками света, а также задания параметров анимации.

Возможности интерфейса:
\begin{itemize}
	\item загрузка модели;
	\item перемещение модели;
	\item поворот модели;
	\item перемещение источника света;
	\item добавление источника света;
	\item задание точек роста;
	\item выбор параметров анимации.
\end{itemize}

\section{Результаты работы программного обеспечения}

На рисунке \ref{growing} представлен процесс роста тровантов.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.23]{assets/growing.jpg}
	\end{center}
	\caption{Рост тровантов}
	\label{growing}
\end{figure}

На рисунке \ref{falling} представлен процесс отпадания тровантов.

\begin{figure}[h!]
	\begin{center}
		\includegraphics[scale=0.23]{assets/falling.jpg}
	\end{center}
	\caption{Отпадание тровантов}
	\label{falling}
\end{figure}

\section*{Вывод}
\addcontentsline{toc}{section}{Вывод}
В данном разделе были рассмотрены требования к ПО, на основе схем из конструкторского раздела были разработаны программные реализации требуемых алгоритмов и представленны их листинги, представлена структура программного обеспечения. Был рассмотрен интерфейс программы и приведены результаты работы программы.